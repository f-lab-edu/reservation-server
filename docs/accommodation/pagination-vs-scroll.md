# 숙소 검색: 페이지네이션 vs 무한 스크롤 정리

## 1. 두 방식의 기본 메커니즘
- **페이지네이션(Offset 기반)**: `LIMIT ?, ?` 형태로 `Pageable`이 만들어 준 `offset`과 `size`를 그대로 사용한다. 사용자가 3페이지를 직접 요청할 수 있고, URL 파라미터만으로 동일한 결과를 재현할 수 있다.
- **무한 스크롤(Cursor 기반, 흔히 No-Offset)**: `WHERE id > :lastId ORDER BY id` 처럼 마지막 레코드의 식별자를 커서로 넘겨 다음 묶음을 가져온다. 스크롤만 내리면 자동으로 이어 붙여져 모바일 UX에 친화적이다.

## 2. 숙소/호텔 서비스가 페이지네이션을 선호하는 이유
1. **탐색 경로 복원 용이**: 날짜·인원·가격 필터를 바꾸어 여러 페이지를 오가는 패턴이 많다. 페이지 번호가 있으면 “3페이지” 상태를 바로 공유하거나 북마크할 수 있다.
2. **결과 범위의 가시성**: “총 215개 중 2페이지”와 같이 탐색 범위를 알려 주어, 사용자가 시간을 얼마나 더 쓸지 판단하게 만든다.
3. **캐싱과 분석이 쉬움**: 페이지 단위는 CDN/서버 캐시 적중률이 높고, SEO·AB 테스트·로그 분석 시에도 페이지별 식별자만 있으면 된다.
4. **하단 영역 활용**: 페이지 끝이 존재하므로 프로모션, 추천 지역, FAQ 등 부가 콘텐츠를 자연스럽게 배치할 수 있다.

## 3. 필터링·정렬과 No-Offset 조합의 한계
- No-Offset은 기본적으로 “정렬 키가 단일 증가값일 때” 가장 효과적이다. 하지만 숙소 검색은 **가격, 거리, 평점, 추천도** 등 다양한 정렬 기준을 제공하고 필터도 다층적이다.
- 정렬이 바뀌면 “마지막 `id`”가 더 이상 다음 페이지를 특정하지 못한다. 예를 들어 가격 오름차순에서는 `price`가 커서가 되어야 하고, 평점순에서는 `(rating, id)` 조합 커서가 필요하다.
- 필터 토글 시 서버는 항상 **새로운 1페이지**를 계산해야 하므로, 커서 기반의 장점(앞부분을 건너뛰지 않음)을 살리지 못하고 구현 복잡도만 커진다.
- 우리 시스템처럼 체크인/아웃, 수용 인원, 가용 객실 여부 등을 한 번에 계산하면, 내부적으로는 집계 쿼리 + 정렬이 필수여서 No-Offset이 크게 이득을 주지 않는다.

```sql
-- No-Offset 예시 (커서가 id에만 묶여 있을 때)
SELECT *
FROM accommodations
WHERE is_visible = true
  AND id > :lastId
ORDER BY id
LIMIT :size;

-- 가격순 정렬 + 필터가 붙으면 커서 정의가 애매해진다.
SELECT *
FROM accommodations
WHERE is_visible = true
  AND price BETWEEN :minPrice AND :maxPrice
ORDER BY price ASC, id ASC
LIMIT :size;
-- → 마지막 가격·id 쌍을 커서로 관리해야 하며, 필터가 바뀌면 처음부터 다시 조회한다.
```

## 4. 무한 스크롤을 선택해야 하는 상황
- 카드 피드처럼 **끝이 없어도 되는 콘텐츠**를 빠르게 소비시키고 싶을 때.
- 정렬 기준이 고정(최신순 등)이고, 필터가 단순하여 커서 정의가 안정적일 때.
- 모바일 전용 UI에서 한 손 스크롤 경험을 최우선으로 둘 때.

## 5. 현재 선택
- 숙소 검색은 필터·정렬 조합이 다양하고, 사용자가 특정 결과 묶음을 반복 비교해야 하므로 **페이지네이션을 기본 방식**으로 유지한다.
- Scroll API는 향후 즐겨찾기/추천 피드처럼 정렬이 단순한 영역에서 Cursor 기반으로 별도 제공하는 방향을 검토한다.
